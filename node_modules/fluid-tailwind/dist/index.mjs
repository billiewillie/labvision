// src/index.ts
import plugin from "tailwindcss/plugin";
import { corePlugins } from "tailwindcss-priv/lib/corePlugins";
import defaultTheme from "tailwindcss/defaultTheme";
import mapObject2, { mapObjectSkip as mapObjectSkip2 } from "map-obj";
import { includeKeys } from "filter-obj";

// src/util/log.ts
import colors from "picocolors";
function log(type, code, message) {
  if (typeof process !== "undefined" && process.env.JEST_WORKER_ID)
    return;
  console.warn(colors.bold(type), "-", colors.bold(code) + ":", message);
}
var warn = (code, message) => log(colors.yellow("warn"), code, message);

// src/util/context.ts
import mapObject, { mapObjectSkip } from "map-obj";

// src/util/errors.ts
var codes = {
  "missing-start": () => "Missing start value",
  "missing-end": () => "Missing end value",
  "missing-default-start-bp": () => "Missing default start breakpoint",
  "missing-default-end-bp": () => "Missing default end breakpoint",
  "non-length-start": (start) => `Start value \`${start}\` is not a length`,
  "non-length-end": (end) => `End value \`${end}\` is not a length`,
  "non-length-start-bp": (bp) => `Start breakpoint \`${bp}\` is not a length`,
  "non-length-end-bp": (bp) => `End breakpoint \`${bp}\` is not a length`,
  "sort-mismatched-bp-units": (key) => `Cannot sort simple breakpoints in \`theme.${key}\` because they use different units`,
  "mismatched-bp-units": (start, end) => `Start breakpoint \`${start.cssText}\` and end breakpoint \`${end.cssText}\` units don't match`,
  "mismatched-bp-val-units": () => `Breakpoint and value units don't match`,
  "mismatched-units": (start, end) => `Start \`${start.cssText}\` and end \`${end.cssText}\` units don't match`,
  "no-change": (val) => `Start and end values are both ${val.cssText}`,
  "no-change-bp": (val) => `Start and end breakpoints are both ${val.cssText}`,
  "bp-not-found": (key, name) => `Could not find \`theme.${key}.${name}\``,
  "no-utility": () => "Fluid variants can only be used with fluid utilities",
  "fails-sc-144": (failingBp) => `Fails WCAG SC 1.4.4 at i.e. ${failingBp.cssText}`
};
var FluidError = class extends Error {
  constructor(code, message) {
    super(message);
    this.code = code;
    this.name = "FluidError";
  }
};
function error(code, ...args) {
  const fn = codes[code];
  const message = fn(...args);
  throw new FluidError(code, message);
}

// src/util/css.ts
var lengthUnits = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh"];
var lengthRegExp = new RegExp(
  `^s*([+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?)(${lengthUnits.join("|")})s*$`
);
var Length = class {
  constructor(number, unit) {
    this.number = number;
    this.unit = unit;
  }
  get cssText() {
    var _a3;
    return `${this.number}${(_a3 = this.unit) != null ? _a3 : ""}`;
  }
  static parse(raw) {
    var _a3;
    if (raw === 0)
      return new this(0);
    if (typeof raw !== "string")
      return null;
    if (parseFloat(raw) === 0)
      return new this(0);
    const match = raw.match(lengthRegExp);
    const number = parseFloat((_a3 = match == null ? void 0 : match[1]) != null ? _a3 : "");
    return isNaN(number) ? null : new this(number, match == null ? void 0 : match[2]);
  }
};

// src/util/set.ts
var tuple = (v) => v;
var unique = (iter) => new Set(iter).size;

// src/util/context.ts
function getContext(theme, { checkSC144 = true } = {}) {
  var _a3;
  const themeConfig = (_a3 = theme("fluid")) != null ? _a3 : {};
  const filterBreakpoints = (key) => {
    const rawBps = theme(key);
    if (Array.isArray(rawBps) || typeof rawBps !== "object")
      return {};
    return mapObject(rawBps, (k, v) => {
      const len = Length.parse(v);
      if (!len)
        return mapObjectSkip;
      return [k, len];
    });
  };
  const sortBreakpoints = (bps, key) => {
    const bpsVals = Object.values(bps);
    if (unique(bpsVals.map((l) => l.unit)) > 1)
      error("sort-mismatched-bp-units", key);
    return bpsVals.sort((a, b) => a.number - b.number);
  };
  let _screens;
  let _sortedScreens;
  let _defaultStartScreen;
  let _defaultEndScreen;
  let _containers;
  let _sortedContainers;
  let _defaultStartContainer;
  let _defaultEndContainer;
  return {
    get screens() {
      return _screens != null ? _screens : _screens = filterBreakpoints("screens");
    },
    get sortedScreens() {
      return _sortedScreens != null ? _sortedScreens : _sortedScreens = sortBreakpoints(this.screens, "screens");
    },
    get defaultStartScreen() {
      var _a4, _b;
      return _defaultStartScreen != null ? _defaultStartScreen : _defaultStartScreen = (_b = (_a4 = themeConfig.defaultScreens) == null ? void 0 : _a4[0]) != null ? _b : this.sortedScreens[0];
    },
    get defaultEndScreen() {
      var _a4, _b;
      return _defaultEndScreen != null ? _defaultEndScreen : _defaultEndScreen = (_b = (_a4 = themeConfig.defaultScreens) == null ? void 0 : _a4[1]) != null ? _b : this.sortedScreens[this.sortedScreens.length - 1];
    },
    get containers() {
      return _containers != null ? _containers : _containers = filterBreakpoints("containers");
    },
    get sortedContainers() {
      return _sortedContainers != null ? _sortedContainers : _sortedContainers = sortBreakpoints(this.containers, "containers");
    },
    get defaultStartContainer() {
      var _a4, _b;
      return _defaultStartContainer != null ? _defaultStartContainer : _defaultStartContainer = (_b = (_a4 = themeConfig.defaultContainers) == null ? void 0 : _a4[0]) != null ? _b : this.sortedContainers[0];
    },
    get defaultEndContainer() {
      var _a4, _b;
      return _defaultEndContainer != null ? _defaultEndContainer : _defaultEndContainer = (_b = (_a4 = themeConfig.defaultContainers) == null ? void 0 : _a4[1]) != null ? _b : this.sortedContainers[this.sortedContainers.length - 1];
    },
    theme,
    checkSC144
  };
}

// src/util/math.ts
var formatters = {};
var toPrecision = (num, precision2) => {
  var _a3;
  return ((_a3 = formatters[precision2]) != null ? _a3 : formatters[precision2] = new Intl.NumberFormat("en-US", {
    maximumFractionDigits: precision2,
    useGrouping: false
  })).format(num);
};
var precision = (num) => {
  var _a3, _b;
  if (Math.floor(num.valueOf()) === num.valueOf())
    return 0;
  return ((_b = (_a3 = num.toString().split(".")) == null ? void 0 : _a3[1]) == null ? void 0 : _b.length) || 0;
};
var clamp = (min, n, max) => Math.min(Math.max(n, min), max);

// src/util/expr.ts
var length = (val, { theme }) => {
  var _a3;
  if (val instanceof Length)
    return val;
  if (typeof val === "string") {
    const [, lookup] = (_a3 = val.match(/^\s*theme\((.*?)\)\s*$/)) != null ? _a3 : [];
    if (lookup)
      val = theme(lookup);
  }
  return Length.parse(val);
};
var resolveBP = (bp, type, context, atContainer) => {
  if (!bp) {
    bp = context[`default${type === "start" ? "Start" : "End"}${atContainer ? "Container" : "Screen"}`];
    if (!bp)
      error(`missing-default-${type}-bp`);
  }
  if (bp instanceof Length)
    return bp;
  const len = length(bp, context);
  if (!len)
    error(`non-length-${type}-bp`, bp);
  return len;
};
var generate = (_start, _end, context, {
  startBP: _startBP,
  endBP: _endBP,
  atContainer,
  type = false,
  final = false
} = {}) => {
  if (!_start)
    error("missing-start");
  const start = length(_start, context);
  if (!start)
    error("non-length-start", _start);
  if (!_end)
    error("missing-end");
  const end = length(_end, context);
  if (!end)
    error("non-length-end", _end);
  const startBP = resolveBP(_startBP, "start", context, atContainer);
  const endBP = resolveBP(_endBP, "end", context, atContainer);
  if (start.number === 0)
    start.unit = end.unit;
  else if (end.number === 0)
    end.unit = start.unit;
  else if (!start.unit || start.unit !== end.unit)
    error("mismatched-units", start, end);
  const unit = start.unit;
  if (start.number === end.number)
    error("no-change", start);
  const comment = (code, ...args) => `/* ${code ? "not " : ""}fluid${type ? " type" : ""} from ${start.cssText} at ${startBP.cssText} to ${end.cssText} at ${endBP.cssText}${atContainer ? " (container)" : ""}${// @ts-expect-error
  code ? ": " + codes[code](...args) : ""} */`;
  if (startBP.number === 0) {
    startBP.unit = endBP.unit;
  } else if (endBP.number === 0) {
    endBP.unit = startBP.unit;
  } else if (!startBP.unit || startBP.unit !== endBP.unit) {
    return (final ? error : comment)("mismatched-bp-units", startBP, endBP);
  }
  if (startBP.number === endBP.number) {
    return (final ? error : comment)("no-change-bp", startBP);
  }
  if (start.unit !== startBP.unit) {
    return (final ? error : comment)("mismatched-bp-val-units");
  }
  const p = Math.max(
    precision(start.number),
    precision(startBP.number),
    precision(end.number),
    precision(endBP.number),
    2
  );
  const min = `${Math.min(start.number, end.number)}${unit}`;
  const max = `${Math.max(start.number, end.number)}${unit}`;
  const slope = (end.number - start.number) / (endBP.number - startBP.number);
  const intercept = start.number - startBP.number * slope;
  if (type && context.checkSC144) {
    const zoom1 = (vw) => clamp(start.number, intercept + slope * vw, end.number);
    const zoom5 = (vw) => clamp(5 * start.number, 5 * intercept + slope * vw, 5 * end.number);
    if (5 * start.number < 2 * zoom1(5 * startBP.number))
      return (final ? error : comment)("fails-sc-144", new Length(startBP.number * 5, startBP.unit));
    else if (zoom5(endBP.number) < 2 * end.number)
      return (final ? error : comment)("fails-sc-144", endBP);
  }
  return `clamp(${min},${toPrecision(intercept, p)}${unit} + ${toPrecision(slope * 100, p)}${atContainer ? "cqw" : "vw"},${max})${comment()}`;
};
var rewrite = (container, context, [startBP, endBP], atContainer) => {
  const contextKey = atContainer ? "containers" : "screens";
  endBP = (() => {
    var _a3;
    if (typeof endBP !== "string")
      return endBP;
    if (/^\[(.*?)\]$/.test(endBP)) {
      return (_a3 = endBP.match(/^\[(.*?)\]$/)) == null ? void 0 : _a3[1];
    } else {
      const bp = context[contextKey][endBP];
      if (!bp)
        error("bp-not-found", contextKey, endBP);
      return bp;
    }
  })();
  let foundExpr = false;
  container.walkDecls((decl) => {
    decl.value = decl.value.replaceAll(
      /(?:clamp\(.*?\))?\/\* (?:not )?fluid( type)? from (.*?) at (.*?) to (.*?) at (.*?)(?: \((container)(?:: )?(.*?)\))?(?:;.*?)? \*\//g,
      (match, type, rawStart, _, rawEnd, __, ___, ____) => {
        foundExpr = true;
        return generate(rawStart, rawEnd, context, {
          startBP,
          endBP,
          atContainer,
          type: Boolean(type),
          final: true
        });
      }
    );
  });
  if (!foundExpr)
    error("no-utility");
};

// src/util/tailwind.ts
var addVariant = (api, variant, definition) => api.addVariant(
  variant,
  // @ts-expect-error undocumented API
  definition
);
var matchVariant = (api, name, cb, options) => api.matchVariant(
  name,
  // @ts-expect-error undocumented API
  cb,
  options
);
var addVariantWithModifier = (api, variant, fn) => api.matchVariant(
  variant,
  // @ts-expect-error undocumented API
  (_, { modifier, container }) => fn({ modifier, container }),
  {
    values: { DEFAULT: null }
  }
);

// src/extractor.ts
import * as regex from "tailwindcss-priv/src/lib/regex";
function extract(contentOrOptions) {
  let patterns = Array.from(buildRegExps(typeof contentOrOptions === "string" ? void 0 : contentOrOptions));
  const extractor = (content) => {
    var _a3;
    let results = [];
    for (let pattern2 of patterns) {
      for (let result of (_a3 = content.match(pattern2)) != null ? _a3 : []) {
        results.push(clipAtBalancedParens(result));
      }
    }
    return results;
  };
  if (typeof contentOrOptions === "string")
    return extractor(contentOrOptions);
  return extractor;
}
var extractor_default = extract;
function* buildRegExps({ separator = ":", prefix: _prefix = "" } = {}) {
  const prefix = _prefix !== "" ? regex.optional(regex.pattern([/-?/, regex.escape(_prefix)])) : "";
  let utility = regex.any([
    // Arbitrary properties (without square brackets)
    /\[[^\s:'"`]+:[^\s\[\]]+\]/,
    // Arbitrary properties with balanced square brackets
    // This is a targeted fix to continue to allow theme()
    // with square brackets to work in arbitrary properties
    // while fixing a problem with the regex matching too much
    /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
    // Utilities
    regex.pattern([
      // Utility Name / Group Name
      regex.any([
        /[-~]?(?:\w+)/,
        // ^ NEW:
        // This is here to make sure @container supports everything that other utilities do
        /@(?:\w+)/
      ]),
      // Normal/Arbitrary values
      regex.optional(
        regex.any([
          regex.pattern([
            // Arbitrary values
            regex.any([
              /-(?:\w+-)*\['[^\s]+'\]/,
              /-(?:\w+-)*\["[^\s]+"\]/,
              /-(?:\w+-)*\[`[^\s]+`\]/,
              /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
            ]),
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\><$]*)?/
          ]),
          regex.pattern([
            // Arbitrary values
            regex.any([
              /-(?:\w+-)*\['[^\s]+'\]/,
              /-(?:\w+-)*\["[^\s]+"\]/,
              /-(?:\w+-)*\[`[^\s]+`\]/,
              /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
            ]),
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\$]*)?/
          ]),
          // Normal values w/o quotes â€” may include an opacity modifier
          /[-\/][^\s'"`\\$={><]*/
        ])
      )
    ])
  ]);
  let variantPatterns = [
    // Without quotes
    regex.any([
      // This is here to provide special support for the `@[]` variant
      regex.pattern([/~?@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]),
      //              ^ NEW:
      // NEW: ~/[arbitrary] and ~@/[arbitrary]
      regex.pattern([/~@?(\w+)?\/\[[^\s"'`]+\]/, separator]),
      // With variant modifier (e.g.: group-[..]/modifier)
      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/\w+/, separator]),
      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]),
      regex.pattern([/[^\s"'`\[\\]+/, separator])
    ]),
    // With quotes allowed
    regex.any([
      // With variant modifier (e.g.: group-[..]/modifier)
      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/\w+/, separator]),
      regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]),
      regex.pattern([/[^\s`\[\\]+/, separator])
    ])
  ];
  for (const variantPattern of variantPatterns) {
    yield regex.pattern([
      // Variants
      "((?=((",
      variantPattern,
      ")+))\\2)?",
      // Important (optional)
      /!?/,
      prefix,
      utility
    ]);
  }
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
function clipAtBalancedParens(input) {
  if (!input.includes("-[")) {
    return input;
  }
  let depth = 0;
  let openStringTypes = [];
  const rawMatches = input.matchAll(SPECIALS);
  const matches = Array.from(rawMatches).flatMap((match) => {
    const [, ...groups] = match;
    return groups.map(
      (group, idx) => Object.assign([], match, {
        index: match.index + idx,
        0: group
      })
    );
  });
  for (let match of matches) {
    let char = match[0];
    let inStringType = openStringTypes[openStringTypes.length - 1];
    if (char === inStringType) {
      openStringTypes.pop();
    } else if (char === "'" || char === '"' || char === "`") {
      openStringTypes.push(char);
    }
    if (inStringType) {
      continue;
    } else if (char === "[") {
      depth++;
      continue;
    } else if (char === "]") {
      depth--;
      continue;
    }
    if (depth < 0) {
      return input.substring(0, match.index - 1);
    }
    if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
      return input.substring(0, match.index);
    }
  }
  return input;
}

// src/index.ts
var handle = (e, source) => {
  if (e instanceof FluidError) {
    warn(source, e.message);
  } else
    throw e;
};
function getFluidAPI(api, context, { filter } = {}) {
  const addFluid = (orig) => (utilities, options) => {
    var _a3;
    if ((options == null ? void 0 : options.type) && !options.type.includes("length") && !options.type.includes("any"))
      return;
    if (filter && !filter(Object.keys(utilities), options))
      return;
    const values = includeKeys(
      (_a3 = options == null ? void 0 : options.values) != null ? _a3 : {},
      (_, v) => Boolean(Length.parse(v))
    );
    const { DEFAULT, ...modifiers } = values;
    Object.entries(utilities).forEach(([util, origFn]) => {
      orig(
        {
          [`~${util}`](start, { modifier: end }) {
            if (end === null && DEFAULT)
              end = DEFAULT;
            try {
              const clamp2 = generate(start, end, context);
              return origFn(clamp2, { modifier: null });
            } catch (e) {
              handle(e, `~${util}`);
              return null;
            }
          }
        },
        {
          ...options,
          values,
          supportsNegativeValues: false,
          // b/c Tailwind only negates the value, not the modifier
          modifiers
        }
      );
    });
  };
  const noop = () => {
  };
  return {
    ...api,
    addUtilities: noop,
    addComponents: noop,
    addVariant: noop,
    addBase: noop,
    matchVariant: noop,
    // @ts-expect-error undocumented API used in corePlugins
    addDefaults: noop,
    matchUtilities: addFluid(api.matchUtilities),
    matchComponents: addFluid(api.matchComponents)
  };
}
var inFluidPlugin = false;
var fluid = plugin.withOptions((options = {}) => (api) => {
  var _a3, _b;
  if (inFluidPlugin)
    return;
  inFluidPlugin = true;
  const { theme, config, corePlugins: corePluginEnabled, matchUtilities } = api;
  const context = getContext(theme, options);
  const { screens: screens2, containers } = context;
  const fontSizeValues = mapObject2(
    (_a3 = theme("fontSize")) != null ? _a3 : {},
    (k, v) => {
      const [fontSize2] = Array.isArray(v) ? v : [v];
      return Length.parse(fontSize2) ? [k, v] : mapObjectSkip2;
    }
  );
  const normalize = (fontSize2) => {
    if (typeof fontSize2 === "string")
      return { fontSize: fontSize2 };
    else if (Array.isArray(fontSize2))
      return typeof fontSize2[1] === "string" ? {
        fontSize: fontSize2[0],
        lineHeight: fontSize2[1]
      } : {
        fontSize: fontSize2[0],
        ...fontSize2[1]
      };
    return {};
  };
  const { DEFAULT, ...fontSizeModifiers } = fontSizeValues;
  matchUtilities(
    {
      "~text"(_from, { modifier: _to }) {
        var _a4, _b2;
        if (_to === null && DEFAULT)
          _to = DEFAULT;
        const from = normalize(_from);
        const to = normalize(_to);
        const rules = {};
        try {
          rules["font-size"] = generate(from.fontSize, to.fontSize, context, {
            type: true
          });
        } catch (e) {
          handle(e, "~text: Font size");
        }
        if (from.lineHeight == to.lineHeight) {
          rules["line-height"] = (_a4 = from.lineHeight) != null ? _a4 : null;
        } else {
          try {
            rules["line-height"] = generate(from.lineHeight, to.lineHeight, context);
          } catch (e) {
            handle(e, "~text: Line height");
          }
        }
        if (from.letterSpacing == to.letterSpacing) {
          rules["letter-spacing"] = (_b2 = from.letterSpacing) != null ? _b2 : null;
        } else {
          try {
            rules["letter-spacing"] = generate(from.letterSpacing, to.letterSpacing, context);
          } catch (e) {
            handle(e, "~text: Letter spacing");
          }
        }
        if (from.fontWeight == to.fontWeight) {
          rules["font-weight"] = from.fontWeight ? from.fontWeight + "" : null;
        } else {
          warn("~text", `Mismatched font weights`);
        }
        return rules;
      }
    },
    {
      values: fontSizeValues,
      modifiers: fontSizeModifiers,
      supportsNegativeValues: false,
      type: ["absolute-size", "relative-size", "length", "percentage"]
    }
  );
  const fluidCoreAPI = getFluidAPI(api, context, {
    // Filter out fontSize plugin
    filter: (utils, options2) => {
      var _a4;
      return !utils.includes("text") || !((_a4 = options2 == null ? void 0 : options2.type) == null ? void 0 : _a4.includes("length"));
    }
  });
  Object.entries(corePlugins).forEach(([name, corePlugin]) => {
    if (!corePluginEnabled(name))
      return;
    corePlugin(fluidCoreAPI);
  });
  const fluidPluginAPI = getFluidAPI(api, context);
  const plugins = config("plugins");
  plugins == null ? void 0 : plugins.forEach((plug, i) => {
    if (!plug)
      return;
    if (typeof plug === "function") {
      if ("__isOptionsFunction" in plug && plug.__isOptionsFunction) {
        plug(void 0).handler(fluidPluginAPI);
      } else {
        plug(fluidPluginAPI);
      }
    } else {
      plug.handler(fluidPluginAPI);
    }
  });
  const separator = (_b = config("separator")) != null ? _b : ":";
  const rewrite2 = (container, [startBP, endBP], variant, atContainer) => {
    var _a4, _b2, _c;
    try {
      rewrite(container, context, [startBP, endBP], atContainer);
      return "&";
    } catch (e) {
      const util = (_c = (_b2 = (_a4 = container.first) == null ? void 0 : _a4.raws) == null ? void 0 : _b2.tailwind) == null ? void 0 : _c.classCandidate;
      handle(e, `${variant}${util ? separator + util : ""}`);
      return [];
    }
  };
  if (screens2 == null ? void 0 : screens2.DEFAULT) {
    warn(
      "inaccessible-default-screen",
      `Your DEFAULT screen breakpoint must be renamed to be used in fluid variants`
    );
  }
  Object.entries(screens2).forEach(([s1Key, s1]) => {
    Object.entries(screens2).forEach(([s2Key, s2]) => {
      if (s2Key === s1Key)
        return;
      addVariant(
        api,
        `~${s1Key}/${s2Key}`,
        ({ container }) => rewrite2(container, [s1, s2], `~${s1Key}/${s2Key}`)
      );
    });
    addVariantWithModifier(
      api,
      `~${s1Key}`,
      ({ container, modifier }) => rewrite2(container, [s1, modifier], `~${s1Key}${modifier ? "/" + modifier : ""}`)
    );
    addVariant(api, `~/${s1Key}`, ({ container }) => rewrite2(container, [, s1], `~/${s1Key}`));
  });
  addVariantWithModifier(
    api,
    "~",
    ({ modifier, container }) => rewrite2(container, [, modifier], `~${modifier ? "/" + modifier : ""}`)
  );
  matchVariant(
    api,
    "~min",
    (value, { modifier, container }) => rewrite2(container, [value, modifier], `~min-[${value}]${modifier ? "/" + modifier : ""}`)
  );
  if (!containers)
    return;
  if (containers == null ? void 0 : containers.DEFAULT) {
    warn(
      "inaccessible-default-container",
      `Your DEFAULT container breakpoint must be renamed to be used in fluid variants`
    );
  }
  Object.entries(containers).forEach(([c1Key, c1]) => {
    Object.entries(containers).forEach(([c2Key, c2]) => {
      if (c2Key === c1Key)
        return;
      addVariant(
        api,
        `~@${c1Key}/${c2Key}`,
        ({ container }) => rewrite2(container, [c1, c2], `~@${c1Key}/${c2Key}`, true)
      );
    });
    addVariantWithModifier(
      api,
      `~@${c1Key}`,
      ({ container, modifier }) => rewrite2(container, [c1, modifier], `~@${c1Key}${modifier ? "/" + modifier : ""}`, true)
    );
    addVariant(
      api,
      `~@/${c1Key}`,
      ({ container }) => rewrite2(container, [, c1], `~@/${c1Key}`, true)
    );
  });
  matchVariant(
    api,
    "~@",
    (value, { modifier, container }) => (
      // can't output ${value} without a reverse lookup from theme :/
      rewrite2(container, [value, modifier], `~@`, true)
    ),
    {
      values: {
        ...containers,
        DEFAULT: null
        // so they can omit it and use expr.defaultContainers; see log.warn above
      }
    }
  );
  inFluidPlugin = false;
});
var src_default = fluid;
var _a;
var screens = mapObject2((_a = defaultTheme.screens) != null ? _a : {}, (name, v) => {
  if (typeof v !== "string")
    return [name, v];
  const len = Length.parse(v);
  if (!len || len.unit !== "px")
    return [name, v];
  return [name, `${len.number / 16}rem`];
});
var _a2;
var fontSize = mapObject2(
  (_a2 = defaultTheme.fontSize) != null ? _a2 : {},
  (name, [_size, { lineHeight: _lineHeight }]) => {
    const size = Length.parse(_size);
    const lineHeightLength = Length.parse(_lineHeight);
    if (!size || lineHeightLength && lineHeightLength.number !== 0 || isNaN(parseFloat(_lineHeight)))
      return [name, tuple([_size, _lineHeight])];
    return [
      name,
      tuple([_size, new Length(parseFloat(_lineHeight) * size.number, size.unit).cssText])
    ];
  }
);
export {
  src_default as default,
  extractor_default as extract,
  fontSize,
  screens
};
