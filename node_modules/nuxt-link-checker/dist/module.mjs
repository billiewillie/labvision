import { useNuxt, extendPages, defineNuxtModule, createResolver, useLogger, addPlugin, addServerHandler, addServerPlugin, hasNuxtModule, hasNuxtModuleCompatibility } from '@nuxt/kit';
import { useSiteConfig, installNuxtSiteConfig } from 'nuxt-site-config-kit';
import { readPackageJSON } from 'pkg-types';
import fs, { readFile, writeFile } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import chalk from 'chalk';
import Fuse from 'fuse.js';
import { resolve, relative } from 'pathe';
import { load } from 'cheerio';
import { parseURL, joinURL, withoutLeadingSlash } from 'ufo';
import { fixSlashes } from 'site-config-stack/urls';
import { toRouteMatcher, createRouter } from 'radix3';
import { $fetch } from 'ofetch';
import { onDevToolsInitialized, extendServerRpc } from '@nuxt/devtools-kit';
import { diffLines, diffArrays } from 'diff';
import MagicString from 'magic-string';

function defineRule(rule) {
  return rule;
}
function isNonFetchableLink(link) {
  return link.startsWith("javascript:") || link.startsWith("blob:") || link.startsWith("data:") || link.startsWith("mailto:") || link.startsWith("tel:") || link.startsWith("#");
}

function RuleTrailingSlash() {
  return defineRule({
    test({ report, link, siteConfig }) {
      if (!link.startsWith("/") && !link.startsWith(siteConfig.url))
        return;
      const $url = parseURL(link);
      const isFile = $url.pathname.split("/").pop().includes(".");
      if ($url.pathname === "/" || isFile)
        return;
      const fix = fixSlashes(siteConfig.trailingSlash, link);
      if (!$url.pathname.endsWith("/") && siteConfig.trailingSlash) {
        report({
          name: "trailing-slash",
          scope: "warning",
          message: "Should have a trailing slash.",
          tip: "Incorrect trailing slashes can cause duplicate pages in search engines and waste crawl budget.",
          fix,
          fixDescription: "Add trailing slash."
        });
      } else if ($url.pathname.endsWith("/") && !siteConfig.trailingSlash) {
        report({
          name: "trailing-slash",
          scope: "warning",
          message: "Should not have a trailing slash.",
          tip: "Incorrect trailing slashes can cause duplicate pages in search engines and waste crawl budget.",
          fix,
          fixDescription: "Removing trailing slash."
        });
      }
    }
  });
}

function RuleMissingHash() {
  return defineRule({
    test({ link, report, ids, fromPath }) {
      const [path, hash] = link.split("#");
      if (!link.includes("#") || link.endsWith("#top") || fixSlashes(false, path) !== fromPath)
        return;
      if (ids.includes(hash))
        return;
      const fuse = new Fuse(ids, {
        threshold: 0.6
      });
      const fixedHash = fuse.search(hash.replace("#", ""))?.[0]?.item;
      const payload = {
        name: "missing-hash",
        scope: "error",
        message: `No element with id "${hash}" found.`
      };
      if (fixedHash) {
        payload.fix = `${link.split("#")[0]}#${fixedHash}`;
        payload.fixDescription = `Did you mean ${payload.fix}?`;
      }
      report(payload);
    }
  });
}

function RuleNoBaseLess() {
  return defineRule({
    test({ link, fromPath, report }) {
      if (link.startsWith("/") || link.startsWith("http") || isNonFetchableLink(link))
        return;
      report({
        name: "no-baseless",
        scope: "warning",
        message: "Should not have a base.",
        fix: `${joinURL(fromPath, link)}`,
        fixDescription: `Add base ${fromPath}.`
      });
    }
  });
}

function RuleNoJavascript() {
  return defineRule({
    test({ link, report }) {
      if (link.startsWith("javascript:")) {
        report({
          name: "no-javascript",
          scope: "error",
          tip: 'Using a <button type="button"> instead as a better practice.',
          message: "Should not use JavaScript"
        });
      }
    }
  });
}

function RuleAbsoluteSiteUrls() {
  return defineRule({
    test({ report, link, siteConfig }) {
      if (!link.startsWith(siteConfig.url))
        return;
      const $url = parseURL(link);
      report({
        name: "absolute-site-urls",
        scope: "warning",
        message: "Internal links should be relative.",
        tip: "Using internal links that start with / is recommended to avoid issues when deploying your site to different domain names",
        fix: $url.pathname,
        fixDescription: `Remove ${siteConfig.url}.`
      });
    }
  });
}

function RuleRedirects() {
  return defineRule({
    test({ report, response }) {
      if (response.status !== 301 && response.status !== 302)
        return;
      const payload = {
        name: "redirects",
        scope: "warning",
        message: "Should not redirect.",
        tip: "Redirects use up your crawl budget and increase loading times, it's recommended to avoid them when possible."
      };
      const fix = typeof response.headers?.get === "function" ? response.headers.get("location") : response.headers?.location || false;
      if (fix) {
        payload.fix = fix;
        payload.fixDescription = `Set to redirect URL ${fix}.`;
      }
      report(payload);
    }
  });
}

function RuleNoErrorResponse() {
  return defineRule({
    test({ link, response, report, pageSearch }) {
      if (!response.status || response.status.toString().startsWith("2") || response.status.toString().startsWith("3") || isNonFetchableLink(link))
        return;
      const payload = {
        name: "no-error-response",
        scope: "error",
        message: `Should not respond with status code ${response.status}${response.statusText ? ` (${response.statusText})` : ""}.`
      };
      if (link.startsWith("/") && pageSearch) {
        const fix = pageSearch.search(link)?.[0]?.item;
        if (fix && fix !== link) {
          payload.fix = fix;
          payload.fixDescription = `Did you mean ${fix}?`;
        }
      } else {
        payload.canRetry = true;
      }
      report(payload);
    }
  });
}

function RuleDescriptiveLinkText() {
  return defineRule({
    test({ textContent, report }) {
      if (typeof textContent === "undefined")
        return;
      if (!textContent) {
        report({
          name: "link-text",
          scope: "warning",
          message: "Should have descriptive text.",
          tip: "Links with descriptive text are easier to understand for screen readers and search engines."
        });
      }
      const uniformLinkText = textContent.trim().toLowerCase();
      const listOfBadDescriptiveLinkTexts = [
        "click here",
        "click this",
        "go",
        "here",
        "this",
        "start",
        "right here",
        "more",
        "learn more"
      ];
      if (listOfBadDescriptiveLinkTexts.includes(uniformLinkText)) {
        report({
          name: "link-text",
          scope: "warning",
          message: "Should have descriptive text.",
          tip: `The ${textContent} descriptive text does not provide any context to the link.`
        });
      }
    }
  });
}

const DefaultInspections = {
  "missing-hash": RuleMissingHash(),
  "no-error-response": RuleNoErrorResponse(),
  "no-baseless": RuleNoBaseLess(),
  "no-javascript": RuleNoJavascript(),
  "trailing-slash": RuleTrailingSlash(),
  "absolute-site-urls": RuleAbsoluteSiteUrls(),
  "redirects": RuleRedirects(),
  "link-text": RuleDescriptiveLinkText()
};
function inspect(ctx, rules = DefaultInspections) {
  const res = { error: [], warning: [], fix: ctx.link, link: ctx.link };
  let link = ctx.link;
  const url = parseURL(link);
  if (!url.pathname && !url.protocol && !url.host && !isNonFetchableLink(link)) {
    res.error.push({
      name: "invalid-url",
      scope: "error",
      message: `Invalid URL: ${link}`
    });
    return res;
  }
  const validInspections = Object.entries(rules).filter(([name]) => !ctx.skipInspections || !ctx.skipInspections.includes(name)).map(([, rule]) => rule);
  for (const rule of validInspections) {
    rule.test({
      ...ctx,
      link,
      url,
      report(obj) {
        res[obj.scope].push(obj);
        if (obj.fix)
          link = obj.fix;
      }
    });
  }
  res.passes = !res.error?.length && !res.warning?.length;
  res.fix = link;
  res.textContent = ctx.textContent;
  return res;
}

function createFilter(options = {}) {
  const include = options.include || [];
  const exclude = options.exclude || [];
  if (include.length === 0 && exclude.length === 0)
    return () => true;
  return function(path) {
    for (const v of [{ rules: exclude, result: false }, { rules: include, result: true }]) {
      const regexRules = v.rules.filter((r) => r instanceof RegExp);
      if (regexRules.some((r) => r.test(path)))
        return v.result;
      const stringRules = v.rules.filter((r) => typeof r === "string");
      if (stringRules.length > 0) {
        const routes = {};
        for (const r of stringRules) {
          if (r === path)
            return v.result;
          routes[r] = true;
        }
        const routeRulesMatcher = toRouteMatcher(createRouter({ routes, ...options }));
        if (routeRulesMatcher.matchAll(path).length > 0)
          return Boolean(v.result);
      }
    }
    return include.length === 0;
  };
}

const responses = {};
async function getLinkResponse({ link, timeout, fetchRemoteUrls, baseURL, isInStorage }) {
  if (link.includes("#") && !link.startsWith("#"))
    link = link.split("#")[0];
  link = decodeURI(link);
  const response = responses[link];
  if (!response) {
    if (isNonFetchableLink(link) || link.startsWith("http") && !fetchRemoteUrls || isInStorage()) {
      responses[link] = Promise.resolve({ status: 200, statusText: "OK", headers: {} });
    } else {
      responses[link] = crawlFetch(link, { timeout, baseURL });
    }
  }
  return responses[link];
}
function setLinkResponse(link, response) {
  responses[link] = response;
}
async function crawlFetch(link, options = {}) {
  const timeout = options.timeout || 5e3;
  const timeoutController = new AbortController();
  const abortRequestTimeout = setTimeout(() => timeoutController.abort(), timeout);
  return await $fetch.raw(encodeURI(link), {
    baseURL: options.baseURL,
    method: "HEAD",
    signal: timeoutController.signal,
    headers: {
      "user-agent": "Nuxt Link Checker"
    }
  }).catch((error) => {
    if (error.name === "AbortError")
      return { status: 408, statusText: "Request Timeout", headers: {} };
    return { status: 404, statusText: "Not Found", headers: {} };
  }).finally(() => clearTimeout(abortRequestTimeout)).then((res) => ({ status: res.status, statusText: res.statusText, headers: res.headers }));
}

const linkMap = {};
function extractPayload(html) {
  const $ = load(html);
  const ids = $("#__nuxt [id]").map((i, el) => $(el).attr("id")).get();
  const links = $("#__nuxt a[href]").map((i, el) => {
    return {
      link: $(el).attr("href"),
      textContent: ($(el).attr("aria-label") || $(el).attr("title") || $(el).text()).trim() || ""
    };
  }).get().filter((l) => !!l.link);
  return { ids, links };
}
function isNuxtGenerate(nuxt = useNuxt()) {
  return nuxt.options._generate || nuxt.options.nitro.static || nuxt.options.nitro.preset === "static";
}
function prerender(config, nuxt = useNuxt()) {
  const urlFilter = createFilter({
    exclude: config.excludeLinks
  });
  nuxt.hooks.hook("nitro:init", async (nitro) => {
    const siteConfig = useSiteConfig();
    nitro.hooks.hook("prerender:generate", async (ctx) => {
      const route = decodeURI(ctx.route);
      if (ctx.contents && !ctx.error && ctx.fileName?.endsWith(".html") && !route.endsWith(".html") && urlFilter(route))
        linkMap[route] = extractPayload(ctx.contents);
      setLinkResponse(route, Promise.resolve({ status: Number(ctx.error?.statusCode) || 200, statusText: ctx.error?.statusMessage || "", headers: {} }));
    });
    nitro.hooks.hook("prerender:done", async () => {
      const payloads = Object.entries(linkMap);
      if (!payloads.length)
        return;
      const links = payloads.map(([, payloads2]) => payloads2.links).flat();
      const pageSearcher = new Fuse(links, {
        threshold: 0.5
      });
      nitro.logger.info("Running link inspections...");
      let routeCount = 0;
      let errorCount = 0;
      const allReports = (await Promise.all(payloads.map(async ([route, payload]) => {
        const reports = await Promise.all(payload.links.map(async ({ link, textContent }) => {
          if (!urlFilter(link))
            return { error: [], warning: [], link };
          const response = await getLinkResponse({
            link,
            timeout: config.fetchTimeout,
            fetchRemoteUrls: config.fetchRemoteUrls,
            isInStorage() {
              return existsSync(resolve(nuxt.options.rootDir, nuxt.options.dir.public, withoutLeadingSlash(link)));
            }
          });
          return inspect({
            ids: linkMap[route].ids,
            fromPath: route,
            pageSearch: pageSearcher,
            siteConfig,
            link,
            textContent,
            response,
            skipInspections: config.skipInspections
          });
        }));
        const errors = reports.filter((r) => r.error?.length).length;
        errorCount += errors;
        const warnings = reports.filter((r) => r.warning?.length).length;
        if (errors || warnings) {
          const statusString = [
            errors > 0 ? chalk.red(`${errors} error${errors > 1 ? "s" : ""}`) : false,
            warnings > 0 ? chalk.yellow(`${warnings} warning${warnings > 1 ? "s" : ""}`) : false
          ].filter(Boolean).join(chalk.gray(", "));
          nitro.logger.log(chalk.gray(
            `  ${Number(++routeCount) === payload.links.length - 1 ? "\u2514\u2500" : "\u251C\u2500"} ${chalk.white(route)} ${chalk.gray("[")}${statusString}${chalk.gray("]")}`
          ));
          reports.forEach((report) => {
            if (report.error?.length || report.warning?.length) {
              nitro.logger.log(chalk.dim(`    ${report.textContent} ${report.link}`));
              report.error?.forEach((error) => {
                nitro.logger.log(chalk.red(`        \u2716 ${error.message}`) + chalk.gray(` (${error.name})`));
              });
              report.warning?.forEach((warning) => {
                nitro.logger.log(chalk.yellow(`        \u26A0 ${warning.message}`) + chalk.gray(` (${warning.name})`));
              });
            }
          });
        }
        return { route, reports };
      }))).flat();
      if (config.report?.html) {
        const reportHtml = allReports.map(({ route, reports }) => {
          const reportsHtml = reports.map((r) => {
            const errors2 = r.error?.map((error) => {
              return `<li class="error">${error.message} (${error.name})</li>`;
            }) || [];
            const warnings2 = r.warning?.map((warning) => {
              return `<li class="warning">${warning.message} (${warning.name})</li>`;
            }) || [];
            const valid = errors2.length + warnings2.length === 0;
            return `<li class="link"><a href="${r.link}">${r.link}</a>${!valid ? `<ul>${[...errors2, ...warnings2].join("\n")}</ul>` : "Valid"}</li>`;
          }).join("\n");
          const errors = reports.filter((r) => r.error?.length).length;
          const warnings = reports.filter((r) => r.warning?.length).length;
          const statusString = [
            errors > 0 ? `${errors} error${errors > 1 ? "s" : ""}` : false,
            warnings > 0 ? `${warnings} warning${warnings > 1 ? "s" : ""}` : false
          ].filter(Boolean).join(", ");
          return `
            <h2><a href="${route}">${route}</a> ${statusString}</h2>
            <ul>
              ${reportsHtml}
            </ul>
            `;
        }).join("");
        const html = `
                <html>
                    <head>
                    <title>Link Checker Report</title>
                    <style>
                        body {
                        font-family: sans-serif;
                        }
                        .link {
                        margin-bottom: 1rem;
                        }
                        /* use a modern, tailwind colour pallet for .error and .warning, do not use red or yellow */
                        .error {
                            color: #F87171;
                        }
                        .warning {
                            color: #FBBF24;
                        }
                    </style>
                    </head>
                    <body>
                    <h1>Link Checker Report</h1>
                    <ul>
                        ${reportHtml}
                    </ul>
                    </body>
                </html>
                `;
        await fs.writeFile(resolve(nitro.options.output.dir, "link-checker-report.html"), html);
        nitro.logger.info(`Nuxt Link Checker HTML report written to ${relative(nuxt.options.rootDir, resolve(nitro.options.output.dir, "link-checker-report.html"))}`);
      }
      if (config.report?.markdown) {
        const reportMarkdown = allReports.map(({ route, reports }) => {
          const reportsMarkdown = reports.map((r) => {
            const errors2 = r.error?.map((error) => {
              return `| ${r.link} | ${error.message} (${error.name}) |`;
            }) || [];
            const warnings2 = r.warning?.map((warning) => {
              return `| ${r.link} | ${warning.message} (${warning.name}) |`;
            }) || [];
            return [...errors2, ...warnings2].filter(Boolean);
          }).flat().filter(Boolean).join("\n");
          const errors = reports.filter((r) => r.error?.length).length;
          const warnings = reports.filter((r) => r.warning?.length).length;
          const statusString = [
            errors > 0 ? `${errors} error${errors > 1 ? "s" : ""}` : false,
            warnings > 0 ? `${warnings} warning${warnings > 1 ? "s" : ""}` : false
          ].filter(Boolean).join(", ");
          return [
            `## [${route}](${route}) ${statusString}`,
            "| Link | Message |",
            "| --- | --- |",
            reportsMarkdown,
            ""
          ].join("\n");
        }).join("\n");
        const markdown = [
          "# Link Checker Report",
          "",
          reportMarkdown
        ].join("\n");
        await fs.writeFile(resolve(nitro.options.output.dir, "link-checker-report.md"), markdown);
        nitro.logger.info(`Nuxt Link Checker Markdown report written to ${relative(nuxt.options.rootDir, resolve(nitro.options.output.dir, "link-checker-report.md"))}`);
      }
      if (errorCount > 0 && config.failOnError) {
        nitro.logger.error(`Nuxt Link Checker found ${errorCount} errors, failing build.`);
        nitro.logger.log(chalk.gray('You can disable this by setting "linkChecker: { failOnError: false }" in your nuxt.config.'));
        process.exit(1);
      }
    });
  });
}

function generateLinkSources(s, link) {
  const regEscapedLink = link.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  const VueLinkRegExp = new RegExp(`(['"])${regEscapedLink}(['"])`);
  const MdLinkRegExp = new RegExp(`\\[.*\\]\\((${regEscapedLink})\\)`);
  const lines = s.split("\n");
  const sources = [];
  for (const [i, line] of lines.entries()) {
    let index = line.search(VueLinkRegExp);
    if (index === -1)
      index = line.search(MdLinkRegExp);
    if (index !== -1) {
      const lineNumber = i + 1;
      const columnNumber = index - 1;
      const start = lines.slice(0, lineNumber - 1).join("\n").length + index + 2;
      const end = start + link.length;
      sources.push({ start, end, lineNumber, columnNumber });
    }
  }
  return sources;
}
function generateLinkDiff(s, originalLink, newLink) {
  const ms = new MagicString(s);
  const sources = generateLinkSources(s, originalLink);
  sources.forEach(({ start, end }) => {
    ms.remove(start, end);
    ms.prependRight(start, newLink);
  });
  return { diff: calculateDiff(s, ms.toString()), code: ms.toString() };
}
function calculateDiff(from, to) {
  const diffs = diffLines(from.trim(), to.trim());
  const added = [];
  const removed = [];
  const result = [];
  for (const diff of diffs) {
    const lines = diff.value.trimEnd().split("\n");
    for (const line of lines) {
      if (diff.added) {
        added.push(result.length);
        result.push(line);
      } else if (diff.removed) {
        removed.push(result.length);
        result.push(line);
      } else {
        result.push(line);
      }
    }
  }
  return {
    added,
    removed,
    result: result.join("\n")
  };
}

function convertNuxtPagesToPaths(pages) {
  return pages.map((page) => {
    return page.children?.length ? page.children.map((child) => {
      return {
        path: joinURL(page.path, child.path),
        page: child
      };
    }) : { page, path: page.path };
  }).flat().filter((p) => !p.path.includes(":")).map((p) => p.path);
}
function useViteWebSocket(nuxt = useNuxt()) {
  return new Promise((_resolve) => {
    nuxt.hooks.hook("vite:serverCreated", (viteServer) => {
      _resolve(viteServer.ws);
    });
  });
}

const DEVTOOLS_UI_ROUTE = "/__nuxt-link-checker";
const DEVTOOLS_UI_LOCAL_PORT = 3030;
const RPC_NAMESPACE = "nuxt-link-checker-rpc";
function setupDevToolsUI(options, resolve, nuxt = useNuxt()) {
  const clientPath = resolve("./client");
  const isProductionBuild = existsSync(clientPath);
  if (isProductionBuild) {
    nuxt.hook("vite:serverCreated", async (server) => {
      const sirv = await import('sirv').then((r) => r.default || r);
      server.middlewares.use(
        DEVTOOLS_UI_ROUTE,
        sirv(clientPath, { dev: true, single: true })
      );
    });
  } else {
    nuxt.hook("vite:extendConfig", (config) => {
      config.server = config.server || {};
      config.server.proxy = config.server.proxy || {};
      config.server.proxy[DEVTOOLS_UI_ROUTE] = {
        target: `http://localhost:${DEVTOOLS_UI_LOCAL_PORT}${DEVTOOLS_UI_ROUTE}`,
        changeOrigin: true,
        followRedirects: true,
        rewrite: (path) => path.replace(DEVTOOLS_UI_ROUTE, "")
      };
    });
  }
  nuxt.hook("devtools:customTabs", (tabs) => {
    tabs.push({
      // unique identifier
      name: "nuxt-link-checker",
      // title to display in the tab
      title: "Link Checker",
      // any icon from Iconify, or a URL to an image
      icon: "carbon:cloud-satellite-link",
      // iframe view
      view: {
        type: "iframe",
        src: DEVTOOLS_UI_ROUTE
      }
    });
  });
  let isConnected = false;
  const viteServerWs = useViteWebSocket();
  const rpc = new Promise((resolve2) => {
    onDevToolsInitialized(async () => {
      const rpc2 = extendServerRpc(RPC_NAMESPACE, {
        getOptions() {
          return options;
        },
        async reset() {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:reset");
        },
        async scrollToLink(link) {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:scroll-to-link", link);
        },
        async applyLinkFixes(filepath, original, replacement) {
          filepath = resolve2(nuxt.options.rootDir, filepath);
          const contents = await readFile(filepath, "utf8");
          const diff = generateLinkDiff(contents, original, replacement);
          await writeFile(filepath, diff.code, "utf8");
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:reset");
        },
        async toggleLiveInspections(enabled) {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:live-inspections", { enabled });
        },
        async connected() {
          const ws = await viteServerWs;
          ws.send("nuxt-link-checker:connected");
          isConnected = true;
        }
      });
      resolve2(rpc2);
    });
  });
  viteServerWs.then((ws) => {
    ws.on("nuxt-link-checker:queueWorking", async (payload) => {
      if (isConnected) {
        const _rpc = await rpc;
        _rpc.broadcast.queueWorking(payload).catch(() => {
        });
      }
    });
    ws.on("nuxt-link-checker:updated", async () => {
      if (isConnected) {
        const _rpc = await rpc;
        _rpc.broadcast.updated().catch(() => {
        });
      }
    });
    ws.on("nuxt-link-checker:filter", async (payload) => {
      if (isConnected) {
        const _rpc = await rpc;
        _rpc.broadcast.filter(payload).catch(() => {
        });
      }
    });
    let lastRoutes = [];
    extendPages(async (pages) => {
      const routes = convertNuxtPagesToPaths(pages);
      if (lastRoutes.length) {
        const routeDiff = diffArrays(lastRoutes, routes);
        if (routeDiff.some((diff) => diff.added || diff.removed))
          ws.send("nuxt-link-checker:reset");
      }
      lastRoutes = routes;
    });
  });
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-link-checker",
    compatibility: {
      nuxt: "^3.9.0",
      bridge: false
    },
    configKey: "linkChecker"
  },
  defaults: {
    strictNuxtContentPaths: false,
    fetchRemoteUrls: false,
    // provider !== 'stackblitz',
    runOnBuild: true,
    debug: false,
    showLiveInspections: false,
    enabled: true,
    fetchTimeout: 1e4,
    failOnError: false,
    excludeLinks: [],
    skipInspections: []
  },
  async setup(config, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const logger = useLogger("nuxt-link-checker");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    const { name, version } = await readPackageJSON(resolve("../package.json"));
    if (config.enabled === false) {
      logger.debug(`The ${name} module is disabled, skipping setup.`);
      return;
    }
    await installNuxtSiteConfig();
    if (config.fetchRemoteUrls) {
      config.fetchRemoteUrls = (await crawlFetch("https://google.com")).status === 200;
      if (!config.fetchRemoteUrls)
        logger.warn("Remote URL fetching is disabled because https://google.com could not be fetched.");
    }
    const isDevToolsEnabled = typeof nuxt.options.devtools === "boolean" ? nuxt.options.devtools : nuxt.options.devtools.enabled;
    if (nuxt.options.dev && isDevToolsEnabled) {
      addPlugin({
        src: resolve("./runtime/nuxt/plugin/ui.client"),
        mode: "client"
      });
      addServerHandler({
        route: "/__link-checker__/inspect",
        handler: resolve("./runtime/nitro/routes/__link-checker__/inspect")
      });
      addServerHandler({
        route: "/__link-checker__/links",
        handler: resolve("./runtime/nitro/routes/__link-checker__/links")
      });
      addServerHandler({
        route: "/__link-checker__/debug.json",
        handler: resolve("./runtime/nitro/routes/__link-checker__/debug")
      });
      addServerPlugin(resolve("./runtime/nuxt/plugin/search.nitro"));
      const pagePromise = new Promise((_resolve) => {
        extendPages((pages) => {
          _resolve(pages);
        });
      });
      nuxt.hooks.hook("nitro:config", (nitroConfig) => {
        nitroConfig.virtual["#nuxt-link-checker-sitemap/pages.mjs"] = async () => {
          const pages = await pagePromise;
          return `export default ${JSON.stringify(convertNuxtPagesToPaths(pages), null, 2)}`;
        };
      });
      const hasSitemapModule = (hasNuxtModule("@nuxtjs/sitemap") || hasNuxtModule("nuxt-simple-sitemap") && await hasNuxtModuleCompatibility("nuxt-simple-sitemap", ">=4")) && nuxt.options.sitemap?.enabled !== false;
      if (!hasNuxtModule("@nuxt/content")) {
        nuxt.options.nitro.alias = nuxt.options.nitro.alias || {};
        nuxt.options.nitro.alias["#content/server"] = resolve("./runtime/nitro/composables/content-mock");
      }
      nuxt.options.runtimeConfig.public["nuxt-link-checker"] = {
        version,
        hasSitemapModule,
        rootDir: nuxt.options.rootDir,
        // @ts-expect-error untyped
        isNuxtContentDocumentDriven: config.strictNuxtContentPaths || hasNuxtModule("@nuxt/content") && nuxt.options.content?.documentDriven,
        excludeLinks: config.excludeLinks,
        skipInspections: config.skipInspections,
        fetchTimeout: config.fetchTimeout,
        showLiveInspections: config.showLiveInspections,
        fetchRemoteUrls: config.fetchRemoteUrls
      };
      setupDevToolsUI(config, resolve);
    }
    if (config.runOnBuild) {
      const isRenderingAllRoutes = isNuxtGenerate(nuxt) && !nuxt.options.nitro.prerender?.crawlLinks;
      if (!nuxt.options._prepare && !nuxt.options.dev && nuxt.options.build && !isRenderingAllRoutes) {
        config.skipInspections.push("no-error-response");
      }
      prerender(config);
    }
  }
});

export { module as default };
